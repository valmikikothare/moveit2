from __future__ import annotations

from typing import Any, Optional

from moveit_msgs.msg import (
    AttachedCollisionObject,
    CollisionObject,
    Constraints,
    ObjectColor,
)

from moveit.core.controller_manager import ExecutionStatus
from moveit.core.planning_scene import PlanningScene
from moveit.core.robot_model import RobotModel
from moveit.core.robot_state import RobotState
from moveit.core.robot_trajectory import RobotTrajectory
from moveit.utils import get_launch_params_filepaths

class MoveItPy:
    """
    A python interface for MoveIt.
    """

    def __init__(
        self,
        node_name: str = "moveit_py",
        name_space: str = "",
        launch_params_filepaths: list[str] = get_launch_params_filepaths(),
        config_dict: Optional[dict[str, Any]] = None,
        provide_planning_service: bool = True,
        remappings: Optional[dict[str, str]] = None,
    ) -> None: ...
    def get_planning_component(self, group_name: str) -> PlanningComponent: ...
    def get_planning_scene_monitor(self) -> PlanningSceneMonitor: ...
    def get_robot_model(self) -> RobotModel: ...
    def get_trajectory_execution_manager(
        self,
    ) -> TrajectoryExecutionManager: ...
    def execute(
        self,
        trajectory: RobotTrajectory,
        blocking: bool = True,
        controllers: Optional[list[str]] = None,
    ) -> ExecutionStatus: ...
    def shutdown(self) -> None: ...

class PlanRequestParameters:
    """
    The parameters for a single planning request.
    """

    planner_id: str
    planning_pipeline: str
    planning_time: float
    planning_attempts: int
    max_velocity_scaling_factor: float
    max_acceleration_scaling_factor: float

    def __init__(self, moveit_py: MoveItPy, name_space: str) -> None: ...

class MultiPipelinePlanRequestParameters:
    """
    The parameters for a multi-pipeline planning request.
    """

    def __init__(
        self, moveit_py: MoveItPy, planning_pipelines: list[str]
    ) -> None: ...
    @property
    def multi_plan_request_parameters(
        self,
    ) -> dict[str, PlanRequestParameters]: ...

class PlanningComponent:
    """
    A component for planning motion for a specific joint model group.
    """

    def __init__(self, group_name: str, moveit_py: MoveItPy) -> None: ...
    @property
    def planning_group_name(self) -> str: ...
    def set_start_state(self, robot_state: RobotState) -> None: ...
    def set_start_state_to_current_state(self) -> None: ...
    @property
    def start_state(self) -> RobotState: ...
    def set_goal_state(
        self,
        robot_state: Optional[RobotState] = None,
        joint_state: Optional[dict[str, float]] = None,
    ) -> None: ...
    def set_path_constraints(self, constraints: Constraints) -> None: ...
    def set_workspace(
        self,
        min_x: float,
        min_y: float,
        min_z: float,
        max_x: float,
        max_y: float,
        max_z: float,
    ) -> None: ...
    def unset_workspace(self) -> None: ...
    @property
    def named_target_states(self) -> list[str]: ...
    def get_named_target_state_values(
        self, target: str
    ) -> dict[str, float]: ...
    def plan(
        self,
        single_plan_request_parameters: Optional[PlanRequestParameters] = None,
        multi_plan_request_parameters: Optional[
            MultiPipelinePlanRequestParameters
        ] = None,
    ) -> RobotTrajectory: ...

class PlanningSceneMonitor:
    """
    Monitors the planning scene for changes.
    """

    def __init__(self, moveit_py: MoveItPy, ns: str = "") -> None: ...
    @property
    def name(self) -> str: ...
    def start_scene_monitor(self, topic: str = "/planning_scene") -> None: ...
    def stop_scene_monitor(self) -> None: ...
    def start_state_monitor(self, topic: str = "/joint_states") -> None: ...
    def stop_state_monitor(self) -> None: ...
    def update_frame_transforms(self) -> None: ...
    def request_planning_scene_state(self) -> None: ...
    def wait_for_current_robot_state(self, timeout: float = 1.0) -> bool: ...
    def process_collision_object(
        self,
        collision_object: CollisionObject,
        color: Optional[ObjectColor] = None,
    ) -> None: ...
    def process_attached_collision_object(
        self, attached_collision_object: AttachedCollisionObject
    ) -> None: ...
    def clear_octomap(self) -> None: ...
    def read_only(self) -> LockedPlanningSceneContextManagerRO: ...
    def read_write(self) -> LockedPlanningSceneContextManagerRW: ...

class LockedPlanningSceneContextManagerRO:
    """
    A context manager for a read-only planning scene.
    """

    def __init__(self, psm: PlanningSceneMonitor) -> None: ...
    def __enter__(self) -> PlanningScene: ...
    def __exit__(self, exc_type, exc_value, traceback) -> None: ...

class LockedPlanningSceneContextManagerRW:
    """
    A context manager for a read-write planning scene.
    """

    def __init__(self, psm: PlanningSceneMonitor) -> None: ...
    def __enter__(self) -> PlanningScene: ...
    def __exit__(self, exc_type, exc_value, traceback) -> None: ...

class TrajectoryExecutionManager:
    """
    Manages the execution of trajectories.
    """

    def __init__(self, moveit_py: MoveItPy) -> None: ...
    def allowed_execution_duration_scaling(self, scaling: float) -> None: ...
    def allowed_goal_duration_margin(self, margin: float) -> None: ...
    def allowed_start_tolerance(self, tolerance: float) -> None: ...
    def allowed_stop_tolerance(self, tolerance: float) -> None: ...
    def are_controllers_active(self, controllers: list[str]) -> bool: ...
    def clear(self) -> None: ...
    def enable_execution_duration_monitoring(self, enable: bool) -> None: ...
    def ensure_active_controller(self, controller: str) -> bool: ...
    def ensure_active_controllers(self, controllers: list[str]) -> bool: ...
    def ensure_active_controllers_for_group(self, group: str) -> bool: ...
    def ensure_active_controllers_for_joints(
        self, joints: list[str]
    ) -> bool: ...
    def execute(
        self,
        trajectory: RobotTrajectory,
        controllers: Optional[list[str]] = None,
    ) -> ExecutionStatus: ...
    def execute_and_wait(
        self, trajectory: RobotTrajectory
    ) -> ExecutionStatus: ...
    def execution_duration_monitoring(self) -> bool: ...
    def execution_velocity_scaling(self, scaling: float) -> None: ...
    def get_last_execution_status(self) -> ExecutionStatus: ...
    def is_controller_active(self, controller: str) -> bool: ...
    def is_managing_controllers(self) -> bool: ...
    def process_event(self) -> None: ...
    def push(
        self,
        trajectory: RobotTrajectory,
        controllers: Optional[list[str]] = None,
    ) -> bool: ...
    def set_allowed_execution_duration_scaling(
        self, scaling: float
    ) -> None: ...
    def set_allowed_goal_duration_margin(self, margin: float) -> None: ...
    def set_allowed_start_tolerance(self, tolerance: float) -> None: ...
    def set_allowed_stop_tolerance(self, tolerance: float) -> None: ...
    def set_execution_velocity_scaling(self, scaling: float) -> None: ...
    def set_wait_for_trajectory_completion(self, wait: bool) -> None: ...
    def stop_execution(self, success: bool = False) -> None: ...
    def wait_for_execution(self) -> None: ...
    def wait_for_trajectory_completion(self) -> bool: ...
