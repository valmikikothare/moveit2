from __future__ import annotations
from typing import Dict, List, Optional
from moveit_msgs.msg import Constraints
from moveit.core.robot_state import RobotState
from rclpy.node import Node
from moveit.core.planning_scene import PlanningScene
from moveit.core.robot_trajectory import RobotTrajectory
from moveit.core.controller_manager import ExecutionStatus


class MoveItPy:
    """
    A python interface for MoveIt.
    """

    def __init__(
        self,
        node: Node,
        use_sim_time: bool,
    ) -> None: ...
    def get_planning_component(self, planning_group: str) -> PlanningComponent: ...
    @property
    def planning_scene_monitor(self) -> PlanningSceneMonitor: ...
    @property
    def robot_model(self) -> "moveit.core.robot_model.RobotModel": ...
    @property
    def trajectory_execution_manager(self) -> TrajectoryExecutionManager: ...
    def execute(
        self, trajectory: RobotTrajectory, blocking: bool = True, controllers: Optional[List[str]] = None
    ) -> ExecutionStatus: ...
    def shutdown(self) -> None: ...


class PlanRequestParameters:
    """
    The parameters for a single planning request.
    """

    def __init__(
        self,
        planning_pipeline: str,
        planner_id: str,
        planning_time: float,
        planning_attempts: int,
        max_velocity_scaling_factor: float,
        max_acceleration_scaling_factor: float,
    ) -> None: ...
    @property
    def planning_pipeline(self) -> str: ...
    @property
    def planner_id(self) -> str: ...
    @property
    def planning_time(self) -> float: ...
    @property
    def planning_attempts(self) -> int: ...
    @property
    def max_velocity_scaling_factor(self) -> float: ...
    @property
    def max_acceleration_scaling_factor(self) -> float: ...


class MultiPipelinePlanRequestParameters:
    """
    The parameters for a multi-pipeline planning request.
    """

    def __init__(self, moveit_py: MoveItPy, planning_pipelines: List[str]) -> None: ...
    @property
    def multi_plan_request_parameters(self) -> Dict[str, PlanRequestParameters]: ...


class PlanningComponent:
    """
    A component for planning motion for a specific joint model group.
    """

    def __init__(self, planning_group: str, moveit_py: MoveItPy) -> None: ...
    @property
    def planning_group_name(self) -> str: ...
    def set_start_state(self, robot_state: RobotState) -> None: ...
    def set_start_state_to_current_state(self) -> None: ...
    @property
    def start_state(self) -> RobotState: ...
    def set_goal_state(self, robot_state: Optional[RobotState] = None, joint_state: Optional[Dict[str, float]] = None) -> None: ...
    def set_path_constraints(self, constraints: Constraints) -> None: ...
    def set_workspace(
        self,
        min_x: float,
        min_y: float,
        min_z: float,
        max_x: float,
        max_y: float,
        max_z: float,
    ) -> None: ...
    def unset_workspace(self) -> None: ...
    @property
    def named_target_states(self) -> List[str]: ...
    def get_named_target_state_values(self, target: str) -> Dict[str, float]: ...
    def plan(
        self,
        single_plan_request_parameters: Optional[PlanRequestParameters] = None,
        multi_plan_request_parameters: Optional[MultiPipelinePlanRequestParameters] = None,
    ) -> RobotTrajectory: ...


class PlanningSceneMonitor:
    """
    Monitors the planning scene for changes.
    """

    def __init__(self, moveit_py: MoveItPy, ns: str = "") -> None: ...
    @property
    def name(self) -> str: ...
    def start_scene_monitor(self, topic: str = "/planning_scene") -> None: ...
    def stop_scene_monitor(self) -> None: ...
    def start_state_monitor(self, topic: str = "/joint_states") -> None: ...
    def stop_state_monitor(self) -> None: ...
    def update_frame_transforms(self) -> None: ...
    def request_planning_scene_state(self) -> None: ...
    def wait_for_current_robot_state(self, timeout: float = 1.0) -> bool: ...
    def process_collision_object(self) -> None: ...
    def process_attached_collision_object(self) -> None: ...
    def clear_octomap(self) -> None: ...
    def read_only(self) -> LockedPlanningSceneContextManagerRO: ...
    def read_write(self) -> LockedPlanningSceneContextManagerRW: ...


class LockedPlanningSceneContextManagerRO:
    """
    A context manager for a read-only planning scene.
    """

    def __init__(self, psm: PlanningSceneMonitor) -> None: ...
    def __enter__(self) -> PlanningScene: ...
    def __exit__(self, exc_type, exc_value, traceback) -> None: ...


class LockedPlanningSceneContextManagerRW:
    """
    A context manager for a read-write planning scene.
    """

    def __init__(self, psm: PlanningSceneMonitor) -> None: ...
    def __enter__(self) -> PlanningScene: ...
    def __exit__(self, exc_type, exc_value, traceback) -> None: ...


class TrajectoryExecutionManager:
    """
    Manages the execution of trajectories.
    """

    def __init__(self, moveit_py: MoveItPy) -> None: ...
    def allowed_execution_duration_scaling(self, scaling: float) -> None: ...
    def allowed_goal_duration_margin(self, margin: float) -> None: ...
    def allowed_start_tolerance(self, tolerance: float) -> None: ...
    def allowed_stop_tolerance(self, tolerance: float) -> None: ...
    def are_controllers_active(self, controllers: List[str]) -> bool: ...
    def clear(self) -> None: ...
    def enable_execution_duration_monitoring(self, enable: bool) -> None: ...
    def ensure_active_controller(self, controller: str) -> bool: ...
    def ensure_active_controllers(self, controllers: List[str]) -> bool: ...
    def ensure_active_controllers_for_group(self, group: str) -> bool: ...
    def ensure_active_controllers_for_joints(self, joints: List[str]) -> bool: ...
    def execute(self, trajectory: RobotTrajectory, controllers: Optional[List[str]] = None) -> ExecutionStatus: ...
    def execute_and_wait(self, trajectory: RobotTrajectory) -> ExecutionStatus: ...
    def execution_duration_monitoring(self) -> bool: ...
    def execution_velocity_scaling(self, scaling: float) -> None: ...
    def get_last_execution_status(self) -> ExecutionStatus: ...
    def is_controller_active(self, controller: str) -> bool: ...
    def is_managing_controllers(self) -> bool: ...
    def process_event(self) -> None: ...
    def push(self, trajectory: RobotTrajectory, controllers: Optional[List[str]] = None) -> bool: ...
    def set_allowed_execution_duration_scaling(self, scaling: float) -> None: ...
    def set_allowed_goal_duration_margin(self, margin: float) -> None: ...
    def set_allowed_start_tolerance(self, tolerance: float) -> None: ...
    def set_allowed_stop_tolerance(self, tolerance: float) -> None: ...
    def set_execution_velocity_scaling(self, scaling: float) -> None: ...
    def set_wait_for_trajectory_completion(self, wait: bool) -> None: ...
    def stop_execution(self, success: bool = False) -> None: ...
    def wait_for_execution(self) -> None: ...
    def wait_for_trajectory_completion(self) -> bool: ...
